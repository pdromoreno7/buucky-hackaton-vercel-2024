'use client'
import { useBookStore } from '@/store'
import { PDFViewer } from '@react-pdf/renderer'
import { useEffect, useState } from 'react'

import Wrapper from '@/components/layouts/Wrapper'
import { MyDocument } from '@/components/pdf/Document'

// const CONTENT = [
//    {
//         "chapterTitle": "Dominando los Fundamentos: Tipos de Datos, Variables y Operadores",
//         "text": "## Dominando los Fundamentos: Tipos de Datos, Variables y Operadores\n\nEn el corazón de cualquier programa Python, yace la habilidad de manipular información. Esta información puede tomar muchas formas, desde números simples hasta cadenas de texto complejas, e incluso estructuras de datos más elaboradas. Para trabajar con estos elementos, Python nos proporciona **tipos de datos**, **variables** y **operadores**. Este capítulo te guiará a través de estos conceptos fundamentales, sentando las bases para tu viaje en el mundo de la programación en Python.\n\n### Tipos de Datos: Los Bloques de Construcción de la Información\n\nImagina los tipos de datos como categorías para la información que tu programa maneja. Python ofrece varios tipos de datos incorporados, cada uno diseñado para un propósito específico. Algunos de los más comunes que encontrarás como principiante son:\n\n* **Enteros (`int`):** Representan números enteros, positivos o negativos, sin decimales. Por ejemplo: `10`, `-5`, `0`.\n* **Flotantes (`float`):** Representan números con decimales, ya sean positivos o negativos. Por ejemplo: `3.14`, `-2.5`, `0.0`.\n* **Cadenas (`str`):** Representan secuencias de caracteres, como palabras o frases. Se definen entre comillas simples (`'`) o dobles (`\"`). Por ejemplo: `'Hola'`, `\"Python\"`, `'¡Bienvenido!'`.\n* **Booleanos (`bool`):** Representan valores de verdad, ya sea `True` (verdadero) o `False` (falso). Son esenciales para la toma de decisiones en la programación.\n\nPython es un lenguaje de tipado dinámico, lo que significa que no necesitas declarar explícitamente el tipo de dato de una variable. Python lo infiere automáticamente en función del valor asignado.\n\n### Variables: Contenedores de Información\n\nEn esencia, las variables son como etiquetas que asignas a diferentes piezas de información en tu programa. Piensa en ellas como contenedores que almacenan datos, permitiéndote acceder y manipular esa información usando el nombre de la variable.\n\nPara crear una variable en Python, simplemente elige un nombre descriptivo y usa el operador de asignación (`=`) para asignarle un valor:\n\n```python\nedad = 25\nnombre = \"Ana\"\nprecio = 19.99\ndisponible = True\n```\n\nEn este ejemplo, hemos creado cuatro variables: `edad` (un entero), `nombre` (una cadena), `precio` (un flotante) y `disponible` (un booleano).\n\n### Operadores: Manipulando la Información\n\nLos operadores son símbolos especiales que realizan operaciones en los datos. Python ofrece una amplia gama de operadores, que se pueden clasificar en diferentes categorías:\n\n* **Operadores aritméticos:** Se utilizan para realizar operaciones matemáticas básicas.\n    * `+` (suma)\n    * `-` (resta)\n    * `*` (multiplicación)\n    * `/` (división)\n    * `//` (división entera)\n    * `%` (módulo, devuelve el resto de una división)\n    * `**` (exponente)\n\n* **Operadores de comparación:** Se utilizan para comparar valores y devolver un valor booleano (`True` o `False`).\n    * `==` (igual a)\n    * `!=` (diferente de)\n    * `>` (mayor que)\n    * `<` (menor que)\n    * `>=` (mayor o igual que)\n    * `<=` (menor o igual que)\n\n* **Operadores lógicos:** Se utilizan para combinar expresiones booleanas.\n    * `and` (y, devuelve `True` si ambas expresiones son verdaderas)\n    * `or` (o, devuelve `True` si al menos una expresión es verdadera)\n    * `not` (no, invierte el valor de verdad de una expresión)\n\nEstos son solo algunos ejemplos de los operadores disponibles en Python. A medida que avances en tu aprendizaje, te encontrarás con otros operadores más especializados.\n\n### Poniendo Todo Junto\n\nCon tu comprensión de los tipos de datos, las variables y los operadores, ahora puedes comenzar a escribir programas Python simples pero poderosos. Por ejemplo, el siguiente código calcula el área de un triángulo:\n\n```python\nbase = 10\naltura = 5\narea = (base * altura) / 2\nprint(\"El área del triángulo es:\", area)\n```\n\nEn este programa, primero definimos dos variables, `base` y `altura`, para almacenar las dimensiones del triángulo. Luego, calculamos el área usando la fórmula del área del triángulo y almacenamos el resultado en la variable `area`. Finalmente, usamos la función `print()` para mostrar el resultado al usuario.\n\nEste capítulo te ha proporcionado una base sólida en los conceptos fundamentales de la programación en Python. A medida que avances en este libro, estos conceptos se volverán cada vez más familiares y te permitirán abordar problemas de programación cada vez más complejos. \n"
//     },
//     {
//         "chapterTitle": "Estructuras de Control de Flujo: Dominando la Lógica Condicional e Iteraciones",
//         "text": "## Dominando la Lógica Condicional e Iteraciones\n\nEn el universo de la programación, la capacidad de dictar el flujo de ejecución de un programa es fundamental. Imaginemos un director de orquesta guiando a los músicos a través de una sinfonía; de la misma manera, las estructuras de control de flujo nos permiten dirigir la ejecución de nuestro código Python. Este capítulo se adentra en el corazón de este concepto, explorando las estructuras de control de flujo que dan vida a la lógica de nuestros programas: sentencias condicionales y bucles.\n\n### Toma de Decisiones con Sentencias Condicionales\n\nLas sentencias condicionales, como su nombre indica, nos permiten ejecutar bloques de código específicos basándonos en la veracidad de ciertas condiciones. Son los puntos de decisión en nuestros programas, permitiéndonos crear caminos alternativos de ejecución.\n\n**La piedra angular de la lógica condicional en Python es la sentencia `if`**. Su sintaxis es sencilla:\n\n```python\nif condición:\n  # Código a ejecutar si la condición es True\n```\n\nSi la `condición` después de la sentencia `if` se evalúa como `True`, el código indentado debajo se ejecuta. Si no, el intérprete de Python ignora ese bloque y pasa a la siguiente línea de código después del bloque `if`.\n\nPara escenarios más complejos donde necesitamos considerar múltiples posibilidades, podemos aumentar nuestra sentencia `if` con las cláusulas `elif` (abreviatura de \"else if\") y `else`:\n\n```python\nif condición1:\n  # Código a ejecutar si la condición1 es True\nelif condición2:\n  # Código a ejecutar si la condición2 es True\nelse:\n  # Código a ejecutar si ninguna de las condiciones anteriores es True\n```\n\nEste constructo nos permite manejar múltiples condiciones secuencialmente. Python comprobará cada condición por turno, y si encuentra una que se evalúa como `True`, ejecutará el bloque de código correspondiente y luego saltará el resto de la estructura `if-elif-else`.\n\n**Operadores de comparación**\n\nLos operadores de comparación son esenciales para construir las condiciones dentro de nuestras sentencias condicionales. Nos permiten comparar valores y determinar la relación entre ellos. Aquí tienes una tabla de los operadores de comparación más comunes en Python:\n\n| Operador | Descripción |\n|---|---|\n| `==` | Igual a |\n| `!=` | No igual a |\n| `>` | Mayor que |\n| `<` | Menor que |\n| `>=` | Mayor o igual que |\n| `<=` | Menor o igual que |\n\n**Operadores lógicos**\n\nLos operadores lógicos nos permiten combinar múltiples condiciones, proporcionando una mayor flexibilidad en nuestras sentencias condicionales. Python proporciona tres operadores lógicos:\n\n* `and`: Devuelve `True` si ambas expresiones a cada lado del operador son `True`.\n* `or`: Devuelve `True` si al menos una de las expresiones a cada lado del operador es `True`.\n* `not`: Invierte el valor de verdad de la expresión que le sigue.\n\n### Automatización con Bucles\n\nLos bucles son la respuesta a la necesidad de ejecutar repetidamente un bloque de código siempre que se cumpla una condición específica. Son la columna vertebral de tareas repetitivas en programación, ahorrándonos la molestia de escribir el mismo código una y otra vez.\n\nPython nos proporciona dos tipos principales de bucles:\n\n**1. El bucle `for`**\n\nEl bucle `for` es ideal para iterar sobre una secuencia de elementos, como una lista o una cadena. Su sintaxis es la siguiente:\n\n```python\nfor elemento in secuencia:\n  # Código a ejecutar para cada elemento de la secuencia\n```\n\nEn cada iteración, el bucle `for` toma el siguiente elemento de la `secuencia` y lo asigna a la variable `elemento`. El bloque de código dentro del bucle se ejecuta entonces utilizando este valor de `elemento`. Este proceso continúa hasta que el bucle ha iterado sobre todos los elementos de la `secuencia`.\n\n**2. El bucle `while`**\n\nEl bucle `while` es más general y se ejecuta mientras una condición específica siga siendo `True`. Su sintaxis es:\n\n```python\nwhile condición:\n  # Código a ejecutar mientras la condición sea True\n```\n\nEl bucle `while` comprueba primero la `condición`. Si la condición es `True`, el código dentro del bucle se ejecuta. Este proceso se repite hasta que la condición se convierte en `False`. Es crucial asegurarse de que la condición dentro del bucle `while` finalmente se convierte en `False`; de lo contrario, el bucle continuará ejecutándose indefinidamente, lo que resultará en un bucle infinito.\n\n**Sentencias de Control de Bucles**\n\nPython proporciona dos sentencias para controlar el flujo de ejecución dentro de los bucles:\n\n* `break`: Termina el bucle por completo y pasa el control a la siguiente sentencia después del bucle.\n* `continue`: Salta la iteración actual y vuelve al principio del bucle, comprobando la condición para la siguiente iteración.\n\n### Conclusión\n\nLas estructuras de control de flujo son los bloques de construcción esenciales de cualquier programa Python. Nos permiten escribir código dinámico y eficiente que puede tomar decisiones y realizar tareas repetitivas. Al dominar las sentencias condicionales y los bucles, desbloqueamos la verdadera potencia de Python, permitiéndonos crear programas sofisticados que pueden resolver una amplia gama de problemas. A medida que profundicemos en el mundo de Python, estos conceptos serán fundamentales para comprender conceptos más complejos y construir aplicaciones robustas. \n"
//     },
// ]

export default function PDFView() {
  const [client, setClient] = useState(false)
  const { dataEbook } = useBookStore()
  console.log('🚀 ~ PDFView ~ dataEbook:', dataEbook)

  useEffect(() => {
    setClient(true)
  }, [])

  return (
    <Wrapper>
      {client && (
        <PDFViewer className='h-full w-full'>
          <MyDocument content={dataEbook?.chaptersWithContent} />
        </PDFViewer>
      )}
    </Wrapper>
  )
}
